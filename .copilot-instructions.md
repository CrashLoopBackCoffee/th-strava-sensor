# GitHub Copilot Instructions

This file provides context and guidelines for GitHub Copilot when working with the Strava Sensor codebase.

## Project Overview

Strava Sensor is a Python tool that extracts device battery information from sports activity FIT files and publishes them as Home Assistant sensors via MQTT. The project emphasizes type safety, modular architecture, and robust error handling.

## Architecture Context

### Core Patterns
- **Strategy Pattern**: Sources implement `BaseSource` for different data retrieval strategies
- **Chain of Responsibility**: Strava source delegates to downstream sources
- **Factory Pattern**: Source initialization based on available configuration
- **Adapter Pattern**: Each source adapts its API to common interface

### Key Components
- **Sources** (`src/strava_sensor/source/`): File, Garmin, and Strava data sources
- **FIT Processing** (`src/strava_sensor/fitfile/`): Binary file parsing and device extraction
- **MQTT** (`src/strava_sensor/mqtt/`): Home Assistant integration via MQTT
- **CLI** (`src/strava_sensor/cli.py`): Command-line interface and orchestration

## Coding Guidelines

### Python Standards
- **Python 3.13+** features preferred
- **Type hints required** for all public APIs
- **Pydantic v2** for data validation
- **Single quotes** for strings
- **100-character line limit**
- **Modern union syntax**: Use `str | None` instead of `Optional[str]`

### Error Handling
- Use **typed exceptions** (`NotAFitFileError`, `CorruptedFitFileError`)
- **Graceful degradation**: Continue processing when possible
- **Structured logging** with appropriate levels
- **User-friendly error messages** for CLI users

### Testing Approach
- **pytest** with descriptive test names: `test__component__scenario`
- **Fixtures** for reusable test data
- **Mocking** for external dependencies
- **High test coverage** (>90% target)

## Code Suggestions

### When adding new sources:
```python
class NewSource(BaseSource):
    uri_scheme = 'new'
    http_hosts = ['api.example.com']
    
    def read_activity(self, uri: str) -> bytearray:
        # Implementation
        pass
    
    def find_activity(self, date, elapsed_time, distance) -> str | None:
        # Optional implementation
        return None
```

### When handling FIT data:
```python
try:
    fitfile = FitFile(activity_data)
    devices = fitfile.get_devices_status()
except (NotAFitFileError, CorruptedFitFileError) as e:
    _logger.error('Failed to parse FIT file: %s', e)
    return
```

### When creating Pydantic models:
```python
class DeviceInfo(pydantic.BaseModel):
    model_config = {
        'extra': 'allow',
        'coerce_numbers_to_str': True,
    }
    
    serial_number: str
    battery_level: int | None = None
    
    @pydantic.model_validator(mode='after')
    def validate_data(self):
        # Custom validation logic
        return self
```

## Dependencies Context

### Core Libraries
- **garmin-fit-sdk**: Binary FIT file parsing (use for all FIT operations)
- **stravalib**: Strava API client (handles OAuth automatically)
- **garminconnect**: Garmin Connect API (requires authentication)
- **paho-mqtt**: MQTT client (use for Home Assistant integration)
- **pydantic**: Data validation (v2 features preferred)

### Development Tools
- **uv**: Package management (use instead of pip)
- **ruff**: Linting and formatting (replaces black, isort, flake8)
- **pyright**: Type checking (strict mode enabled)
- **pytest**: Testing framework with coverage

## Common Patterns

### URI Handling
```python
def parse_activity_uri(uri: str) -> tuple[str, str]:
    """Parse activity URI to extract scheme and identifier."""
    result = urllib.parse.urlparse(uri)
    if result.scheme == 'garmin':
        return 'garmin', result.netloc
    elif result.scheme == 'https' and 'strava.com' in result.hostname:
        return 'strava', result.path.split('/')[-1]
    else:
        raise ValueError(f'Unsupported URI: {uri}')
```

### Logging Setup
```python
import logging
_logger = logging.getLogger(__name__)

# Use structured logging
_logger.info('Processing activity %s with %d devices', activity_id, len(devices))
_logger.debug('Device details: %s', device.model_dump())
_logger.warning('Missing battery data for device %s', device.serial_number)
```

### MQTT Publishing
```python
def publish_device_status(device: DeviceStatus, mqtt_client: MQTTClient):
    """Publish device status to MQTT with Home Assistant discovery."""
    # Status data
    status_topic = f'strava/{device.serial_number}/status'
    mqtt_client.publish(status_topic, device.model_dump_json())
    
    # Discovery configuration
    discovery_topic = f'homeassistant/device/strava-{device.serial_number}/config'
    discovery_payload = create_discovery_payload(device, status_topic)
    mqtt_client.publish(discovery_topic, json.dumps(discovery_payload))
```

## Testing Patterns

### Fixture Usage
```python
@pytest.fixture
def sample_fit_data() -> bytearray:
    """Load sample FIT file for testing."""
    fit_path = pathlib.Path(__file__).parent / 'fixtures' / 'activity.fit'
    return bytearray(fit_path.read_bytes())

def test__fitfile__parse_devices(sample_fit_data):
    """Test that FIT file parsing extracts device information."""
    fitfile = FitFile(sample_fit_data)
    devices = fitfile.get_devices_status()
    assert len(devices) > 0
    assert all(device.serial_number for device in devices)
```

### Mocking External APIs
```python
@patch('strava_sensor.source.garmin.garminconnect.Garmin')
def test__garmin_source__read_activity(mock_garmin_class):
    """Test Garmin source activity reading."""
    mock_garmin = mock_garmin_class.return_value
    mock_garmin.download_activity.return_value = b'mock_zip_data'
    
    source = GarminSource('user', 'pass')
    result = source.read_activity('garmin://123456')
    
    assert isinstance(result, bytearray)
    mock_garmin.download_activity.assert_called_once()
```

## Performance Considerations

### Memory Usage
- **Stream large files** when possible
- **Release references** to large objects early
- **Use generators** for processing sequences

### API Efficiency
- **Cache authentication tokens** (Garmin does this automatically)
- **Batch API requests** when supported
- **Implement retry logic** with exponential backoff

### Concurrency
- Current implementation is **synchronous**
- Consider **async/await** for I/O-bound operations
- Use **concurrent.futures** for CPU-bound tasks

## Security Best Practices

### Credential Handling
```python
# Use environment variables
garmin_username = os.environ.get('GARMIN_USERNAME')
if not garmin_username:
    raise ValueError('GARMIN_USERNAME environment variable required')

# Store tokens securely
tokenstore = pathlib.Path('~/.garminconnect').expanduser()
garmin.garth.dump(str(tokenstore))
```

### Input Validation
```python
def validate_activity_uri(uri: str) -> str:
    """Validate and normalize activity URI."""
    try:
        result = urllib.parse.urlparse(uri)
        if not result.scheme:
            raise ValueError('URI must include scheme')
        return uri
    except Exception as e:
        raise ValueError(f'Invalid URI format: {e}') from e
```

## Home Assistant Integration

### Device Discovery
```python
def create_ha_device_config(device: DeviceStatus) -> dict:
    """Create Home Assistant device configuration."""
    return {
        'dev': {
            'ids': f'strava-{device.serial_number}',
            'name': f'Strava {device.device_type} {device.serial_number}',
            'mf': device.manufacturer,
            'mdl': device.product,
            'sn': device.serial_number,
        },
        'o': {'name': 'Strava-Tool', 'sw': '0.0.1'},
    }
```

### Sensor Configuration
- Use **appropriate device classes** (battery, voltage, enum)
- Include **units of measurement** (V, %)
- Provide **value templates** for JSON parsing
- Set **unique IDs** for entity identification

## Troubleshooting Context

### Common Issues
- **FIT file corruption**: Handle gracefully with specific exceptions
- **API authentication**: Check token expiration and refresh
- **MQTT connection**: Implement connection retry logic
- **Missing device data**: Use default values and log warnings

### Debugging Tips
- **Enable debug logging**: `daiquiri.setup(level=logging.DEBUG)`
- **Check environment variables**: All sources require proper configuration
- **Validate FIT files**: Use Garmin tools to verify file integrity
- **Test MQTT connectivity**: Use MQTT client tools for debugging

This context should help Copilot generate appropriate code suggestions that align with the project's architecture, coding standards, and best practices.